#+TITLE:     Shell configuration files
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   num:nil ^:{}

#+PROPERTY:  eval no
# #+SETUPFILE: bigblow-pirilampo.setup
#+SETUPFILE: ~/src/org-html-themes/setup/theme-readtheorg-local-abs.setup

* Documentation

[[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]]

* Cygwin

- After Cygwin is installed, modify the System ~PATH~ variable: append
  =C:\cygwin\bin= before ~%SystemRoot%\system32~

- If you add other directories (such as =~/bin= or =~/winbin=) in the ~PATH~ before
  Cygwin, please check that those directories don't contain =cygwin1.dll= or
  such. That was why I had troubles running ~git~ commands...

- Programs like ~ssh~ rely on =/etc/passwd= rather than your environment variable
  ~HOME~ for the location of your home directory.

  Hence, change your [[http://www.cygwin.com/faq/faq-nochunks.html#faq.setup.home][Cygwin home directory]] by editing the penultimate element
  on your user's line in =/etc/passwd= (the ~HOME~ environment variable is set
  from that field).

** Packages

ftp://ftp.cygwinports.org/pub/cygwinports/ is the most popular choice.

*************** TODO See http://www.4thinker.com/cygwin-setup.html
*************** END

Install extra packages:

- Archive
  + [ ] ~zip~ used by the "Org to ODT" exporter
  + [ ] ~unzip~

- Devel
  + [X] ~git~
  + [X] ~subversion~ (for ~svn~ command)
  + [X] ~gdb~
  + [ ] ~autoconf~
  + [ ] ~bzr~
  + [ ] ~cvs~
  + [ ] ~ctags~ (Exuberant Ctags)
  + [ ] ~gcc-core~ (C compiler)
  + [ ] ~gcc4~ (needed for installing some Perl packages, for CSV2Ledger)
  + [ ] ~make~
  + [ ] ~mercurial~ (for ~hg~ command, used by Beamer)

- Editors
  + [X] ~emacs~
  + [X] ~emacs-w32~ (for graphical Cygwin Emacs with the w32 graphics toolkit)
  + [X] ~emacs-el~ (needed to get more up-to-date sources, such as for Org)

- Graphics
  + [ ] ~ghostscript~ (needed by various utilities)
  + [ ] ~gnuplot~

- Interpreters
  + [ ] ~m4~

- Libs
  + [ ] ~libbz2-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiconv~
  + [ ] ~libicu-devel~ (needed for installing RODBC inside R)
  + [ ] ~libiodbc-devel~ (needed for installing RODBC inside R)

- Math
  + [X] ~R~

- Net
  + [ ] ~bind-utils~ (for getting ~dig~, ~host~, ~nslookup~, etc.)
  + [ ] ~inetutils~ (for getting ~telnet~ to work with expect)
  + [ ] ~nc~ (see socat)
  + [ ] ~openssh~
  + [ ] ~ping~ (Note: Allow to "Run this program as an administrator")
  + [ ] ~rsync~
  + [ ] ~socat~ (see nc)

- Perl
  + [ ] ~perl~

- Ruby
  + [ ] ~ruby~

- Python
  + [X] ~python~

- Shells
  + [X] ~zsh
  + [ ] ~rxvt~

- System
  + [ ] ~procps~ (to get ~top~)
  + [ ] ~psmisc~ (to get ~killall~)

- Tcl
  + [ ] ~expect~

- Text
  + [ ] ~antiword~
  + [ ] ~aspell~ (Win32 binary has more dictionaries)
  + [ ] ~most~
  + [ ] ~opensp~ (for ~nsgmls~ validator)
  + [ ] ~tidy~

- Utils
  + [X] ~gnupg~ (~gpg~)
  + [ ] ~fdupes~
  + [ ] ~file~ to determine file type
  + [ ] ~flog~ (logger, to syslog)
  + [ ] ~ncurses~ (provides the ~clear~ command used by the TeX Live installer,
    though you can use ~C-l~ to get the same result)
  + [ ] ~patch~ and ~patchutils~
  + [ ] ~screen~

- X11
  + [ ] ~fontconfig~ (needed by XeTeX)
  + [ ] ~libXaw7~ (needed by ~xdvi~)

- Web
  + [X] ~curl~
  + [ ] ~w3m~
  + [ ] ~wget~

** Change your Cygwin ~HOME~ folder

If you installed Cygwin prior to 1.7.34 or have run its ~mkpasswd~ utility so that
you have an =/etc/passwd= file, you can change your Cygwin ~HOME~ directory by
editing your user's entry in that file. Your ~HOME~ directory is the
second-to-last element on your user's line in =/etc/passwd=.

Starting with Cygwin 1.7.34, the recommended way to do this is to add a custom
~db_home~ setting to =/etc/nsswitch.conf=.

** GnuPG

When first running ~gpg~:

- Directory =~/.gnupg= created
- New configuration file =~/.gnupg/gpg.conf= created
- Keyring =~/.gnupg/secring.gpg= created
- Keyring =~/.gnupg/pubring.gpg= created

** Suppress the Cygwin DOS path warning

When first running ~M-x ediff-buffers~, I got this Cygwin warning:

#+begin_example
MS-DOS style path detected: c:/Users/...
Preferred POSIX equivalent is: /cygdrive/c/Users/...
CYGWIN environment variable option "nodosfilewarning" turns off this warning.
Consult the user's guide for more details about POSIX paths:
  http://cygwin.com/cygwin-ug-net/using.html#using-pathnames
#+end_example

Though, setting it in =.bashrc= or something like that does not work. A good
place to set it is in the global *Windows environment variables*.

** Suppress the annoying "tty option" warning

#+begin_example
"tty" option detected in CYGWIN environment variable.
CYGWIN=tty is no longer supported.  Please remove it from your
CYGWIN environment variable and use a terminal emulator like mintty,
xterm, or rxvt.
#+end_example

This is not a Cygwin problem: ~Emacs-w3m~ used to set the ~CYGWIN~ environment
variable in =w3m.el=. Just edit that file and remove the setting. Alternatively,
it looks like you could solve the problem by customizing
~w3m-command-environment~.

Though, downloading (via the anonymous CVS server) the latest source code from
http://emacs-w3m.namazu.org/ also solves the problem.

* Startup files

There are 3 *sorts of shells*:

- (interactive) *login* (for which =c:/cygwin/etc/profile= and =.profile= are read,
  which sources =.bashrc= as well)

  #+begin_note
  Launching Cygwin Terminal (login shell) does not load =.bashrc= on its own, it
  only loads =.bash_profile=. Hence, the need to have a =.bash_profile= sourcing
  =.bashrc=...
  #+end_note

- *interactive* (non-login) (for which =.bashrc= is read)

- normal shell, i.e. one that's running a *script* (Bash does not execute any
  initialization file in this case!)

  ~$tty~ is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For Bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.
- For Zsh, put stuff in =~/.zshrc=, which is always executed.

To recover the default bash configuration files, get their copy from
=/etc/skel=.

If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.

** What to put where?

Login shell runs =.profile= (or =.bash_profile= or =.bash_login=) on startup. Set your
env variables in there, because sub-shells will inherit the env vars. Then make
=.profile= run your =.bashrc=:

#+begin_src shell
. .bashrc
#+end_src

Interactive runs =.bashrc=. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare minimum. Therefore
your ~PATH~ won't work very well so you often have to give an absolute pathname
like in ~crontab~:

#+begin_src shell
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** Note

In =c:/cygwin64/etc/profile=,

- =/usr/local/bin= is appended to the ~PATH~!!

  And, except when root, it is almost always wrong to have =/usr/local/bin= after
  any system path.

- ~TZ~ (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from =c:/cygwin/Cygwin.bat=!!

* Bash specific
  :PROPERTIES:
  :tangle:   ./src/.bashrc
  :END:

Le ~!~ en shell permet plein de trucs sympa.

- ~!!~ refait la dernière commande
- ~!cmd~ refait la dernière commande commençant par ~cmd~
- ~!cmd:p~ permet de visualiser sans éxecuter la dernière commande commençant
  par ~cmd~
- ~!$~ est le dernier mot de la ligne de commande précédente
- ~!cmd:$~ est le dernier mot du dernier ligne de commande commençant par ~cmd~
- ~!*~ est l'ensemble de la dernière ligne de commande à part le premier mot

Pourquoi ce dernier est-il utile ?  Pense à ceci :

#+begin_src shell :tangle no
$ gm convret -size 120x120 input.png -resize 120x120 -draw "gravity southeast text 0,0 'Dave Neary'" output.jpg
bash: convret: command not found
$ gm convert !*
#+end_src

** Profile

#+begin_src shell :tangle ./src/.bash_profile
# User dependent .bash_profile file

# source the user's .bashrc if it exists
if [ -f "${HOME}/.bashrc" ] ; then
  source "${HOME}/.bashrc"
fi
#+end_src

** Preamble

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no :exports none
(format-time-string "%Y")
#+end_src

#+begin_src shell :noweb yes
## .bashrc --- Bourne Again Shell configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

#* Code:
#+end_src

I think the following is important for tools such as ~rsync~ (and Emacs
Tramp?)...

#+begin_src shell
# if not running interactively, don't do anything
[[ "$-" != *i* ]] && return
#+end_src

** Variables

*** Search path

Where to look for executable files.

The global search ~PATH~ is defined in the file =/etc/environment=.

#+begin_note
~PATH~ should already be marked as exported, so reexporting is not needed.
#+end_note

#+begin_src shell
# specify the directories that the shell is to look through to find a
# command. These directories are searched in the order in which they appear.
for MAYBE_PATH in "$HOME/bin" \
                  "$HOME/expect" \
                  "$HOME/winbin"
do
    if [ -d "$MAYBE_PATH" ]; then
        PATH="$MAYBE_PATH:$PATH"
    fi
done
#+end_src

By default, the ~root~ shell does not load commands from the current location.  If
you're ~root~ and if you trust those commands, type ~./whatever-command~ instead.

#+begin_src shell
# add the current directory as last component in the search path
# (not to include for root, for security reasons)
if [ ! "$(id -u)" = "0" ]; then
    PATH="$PATH:."
fi
#+end_src

*** Prompt

Appearance of the prompt.

Note ~\[...\]~ used by the shell to count proper length.

#+begin_src shell
#*** Controlling the Prompt

# regular colors
green="\[\e[0;32m\]"
yellow="\[\e[0;33m\]"

# bold colors
BLACK="\[\e[1;30m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"

reset="\[\e[0m\]"

#**** PS1 --- Default interaction prompt

#**** PS2 --- Continuation interactive prompt

#**** PS3 --- Prompt used by "select" inside shell script

#**** PS4 --- Used by "set -x" to prefix tracing output

# get line numbers when you run with `-x'
PS4='+'${green}'[$0:${LINENO}]+ '${reset}
# single quotes (otherwise, this line number is taken)

# If you are looking at performance issues, put `$SECONDS' in the PS4 prompt
# as well
#+end_src

#+begin_src shell
#**** PROMPT_COMMAND

# to be called just before the prompt is printed
precmd ()
{
    RET=$?

    # set a color prompt (unless in Emacs)
    case $TERM in
        cygwin|xterm*|rxvt-unicode)
            local color_prompt=yes
            ;;
        dumb)
            # `M-x shell' under Cygwin Emacs
            # `M-x eshell' under EmacsW32
            # Tramp
            local color_prompt=no
            ;;
        emacs)
            # `M-x shell' under EmacsW32
            local color_prompt=no
            ;;
        eterm-color)
            # `M-x term' under Cygwin Emacs
            local color_prompt=no
            ;;
    esac

    # colorful prompt, based on whether the previous command succeeded or not
    if [ $RET -eq 0 ]; then
        HILIT_RET=${GREEN}
    else
        HILIT_RET=${RED}
    fi

    # replace the `$HOME' prefix by `~' in the current directory
    if [ "$HOME" = "${PWD:0:${#HOME}}" ]; then
        myPWD="~${PWD:${#HOME}}"
    else
        myPWD=$PWD
    fi

    # how many characters of the path should be kept
    local pwd_max_length=15

    if [ ${#myPWD} -gt $pwd_max_length ]; then
        local pwd_offset=$(( ${#myPWD} - $pwd_max_length ))
        myPWD="...${myPWD:$pwd_offset:$pwd_max_length}"
    fi

    # prompt character
    if [ "$USERNAME" = "root" ]; then
        local PROMPTCHAR="#"
    else
        local PROMPTCHAR="$"
    fi

    if [ "$color_prompt" = "yes" ]; then
        PS1="${green}\u@\h${BLACK}:${yellow}${myPWD}${HILIT_RET} ${RET}${reset}${PROMPTCHAR} "
    else
        PS1="\u@\h:${myPWD} ${RET}${PROMPTCHAR} "
    fi
}

# execute the content of the `PROMPT_COMMAND' just before displaying the `PS1'
# variable (but don't confuse Tramp)
[ $TERM = "dumb" ] || PROMPT_COMMAND=precmd
#+end_src

*** Command history

Access and modify commands that you had previously typed at the command line.

#+begin_src shell
# history
HISTFILE=$HOME/.bash_history # if paranoiac, `/dev/null'
HISTSIZE=1000
HISTFILESIZE=1000
HISTIGNORE="&:[bf]g:exit"
HISTCONTROL=ignoredups
#+end_src

*** Term

*** Display

** Code

#+begin_src shell
#** Source global rc file (if any)

# source global definitions if the session is interactive (to avoid problems
# like "stdin: is not a tty" when ssh'ing to a remote machine)
if ([ $(expr index "$-" i) -ne 0 ] && [ -f /etc/bashrc ]); then
    . /etc/bashrc
fi
#+end_src

A common cause is ~mesg y~ in =/etc/bashrc= on the remote machine, hence the user
has to try avoiding sourcing it (on the *remote* machine) in non-interactive
sessions.

#+begin_src shell
#** Default permissions

# permissions on newly created files
umask 022 # prevent new dirs and files from being group and world writable

if [ "$USERNAME" = "root" ]; then
    umask 077  # stricter
fi
#+end_src

#+begin_src shell
#** Shell options

# correct minor misspellings of cd pathnames
shopt -s cdspell
#+end_src

** Next

#+begin_src shell
#** 5 (info "(bashref)Shell Variables")

# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
#if [ -d $HOME/man ]; then
#    MANPATH=$HOME/man:"${MANPATH}"
#    export MANPATH
#fi

# LANG="en_US.utf8"
# LC_CTYPE="en_US.utf8"
# LC_ALL="C"   # fixes the problem of strange characters in the man page
# XXX These should be set in `/etc/default/locale', via `sudo update-locale'

# XXX Set DISPLAY?

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'

# Info readers (standalone + Emacs Info mode)
INFOPATH="/usr/share/info:$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
INFOPATH="$HOME/src/emacs-w3m/doc:$INFOPATH"
INFOPATH="$HOME/src/gnus/texi:$INFOPATH"
INFOPATH="$HOME/Downloads/emacs/site-lisp/auctex-11.86/doc:$INFOPATH"
# INFOPATH="$HOME/texlive/2014/texmf/doc/info:$INFOPATH"
INFOPATH="$HOME/Public/Repositories/org-mode/doc:$INFOPATH"
#+end_src

#+begin_src shell :tangle no
# Functions to help us manage environment variables

# setenv [VAR] [value] - set environment variable
setenv () { eval $1="\$2" export $1; }

# unsetenv [VAR] - unset environment variable
unsetenv () { unset "$@"; }

# ifnset [VAR] [value] - set environment variable only if not set yet
ifnset () { eval $1=\${$1-"\$2"} export $1; }

# ifnull [VAR] [value] - set environment variable if not set yet or if NULL
ifnull () { eval $1=\${$1:-"\$2"} export $1; }

# append [VAR] [path] - append path separated by `:'
append () { eval $1=\${$1:+\$$1${2:+:}}\$2 export $1; }

# prepend [VAR] [path] - prepend path separated by `:'
prepend () { eval $1=\$2\${$1:+${2:+:}\$$1} export $1; }

# showvalue [VAR]... - print out the value of variables given their name
showvalue () { for i in $*; do eval echo "$i = \\\`\$$i\'"; done; }
#+end_src

** Source common files

=.commonshrc= contains miscellaneous definitions common to Bash and Zsh.

An *alias* is a simple string substitution.

#+begin_note
By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).
#+end_note

In general, it should not do more than *change the default options of a command*.

#+begin_src shell
#** 4.2 or 6.6 Aliases

# source common definitions
if [ -r "$HOME/.commonshrc" ]; then
    . $HOME/.commonshrc
fi
#+end_src

** Next

#+begin_src shell
# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23


#** 8.6 Programmable Completion

complete -A helptopic help
complete -A hostname ssh telnet nmap rlogin ftp ping host traceroute nslookup rexec


#** Misc functions

saneperms ()
{
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod ${1:=644}
}


# # search for various types or README file in dir and display them in $PAGER
# readme ()
# {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }

# # Get a file's basename, dirname, extension, etc
#
# # get extension; everything after last '.'
# ext=${file##*.}
#
# # basename
# basename=`basename "$file"`
# # everything after last '/'
# basename=${file##*/}
#
# # dirname
# dirname=`dirname "$file"`
# # everything before last '/'
# basename=${file%/*}

safetmp ()
{
    test -d $HOME || exit 1
    test -d $HOME/tmp || mkdir $HOME/tmp
    echo $HOME/tmp/safetmp.$(hostname).$(date +%s).$$
}

# gpg
searchkey ()
{
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@";
}

#*** GPG functions

encrypt ()
{
    # Use ascii armor
    gpg -ac --no-options "$1"
}

bencrypt ()
{
    # No ascii armor
    # Encrypt binary data. jpegs/gifs/vobs/etc.
    gpg -c --no-options "$1"
}

decrypt ()
{
    gpg --no-options "$1"
}

pe ()
{
# Passphrase encryption program
# Created by Dave Crouse 01-13-2006
# Reads input from text editor and encrypts to screen.
    clear
    echo "         Passphrase Encryption Program";
    echo "--------------------------------------------------"; echo "";
    which $EDITOR &>/dev/null
    if [ $? != "0" ]; then
        echo "It appears that you do not have a text editor set in your .bashrc file.";
        echo "What editor would you like to use ? " ;
        read EDITOR ; echo "";
    fi
    echo "Enter the name/comment for this message :"
    read comment
    $EDITOR passphraseencryption
    gpg --armor --comment "$comment" --no-options --output
    passphraseencryption.gpg --symmetric passphraseencryption
    shred -u passphraseencryption ; clear
    echo "Outputting passphrase encrypted message"; echo "" ; echo "" ;
    cat passphraseencryption.gpg ; echo "" ; echo "" ;
    shred -u passphraseencryption.gpg ;
    read -p "Hit enter to exit" temp; clear
}

keys ()
{
    # Opens up kgpg keymanager
    kgpg -k
}
#+end_src

#+begin_src shell
timesync ()
{
    if [ $(id -u) = 0 ]; then
        ntpdate -u swisstime.ethz.ch
    else
        echo "Must be root"
    fi
}

# immediately opens the first match
texman ()
{
    locate $* | grep pdf | grep texlive | head -1 | xargs open;
}

texlist ()
{
    locate $* | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)";
}
#+end_src

** Postamble

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: shell-script
# mode: outline-minor
# sh-shell: bash
# End:

## .bashrc ends here
#+end_src

** InputRC
   :PROPERTIES:
   :tangle:   ./src/.inputrc
   :END:

This file controls the behavior of line input editing for programs that use
the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

#+begin_note
Zsh doesn't use the =inputrc= file.
#+end_note

#+begin_src shell :noweb yes
## .inputrc --- my Readline Init File

# Copyright (C) 2005-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: readline, dotfile, config

#* Code:

# first, include any system-wide settings (ignored if one has his own
# `.inputrc')
$include /etc/skel/.inputrc
$include /etc/inputrc

# allow Meta (Alt) key bindings [line added to the top of my `.inputrc']
set convert-meta on

# behave like Emacs when editing
set editing-mode emacs
    # Ctrl-a/e      Start/End of line
    # Ctrl-f/b      Forward/Backward one character
    # Ctrl-d        Delete one character
    # Ctrl-k        Kill line
    # Ctrl-p/n      Previous/Next command in history
    # Ctrl-r        Search for command in history
    # Ctrl-i/TAB    File name completion

# some defaults / modifications for the Emacs mode
$if mode=emacs

# mappings for `Ctrl-up/down' for matching commands from the history
"\e[1;5A": history-search-backward
"\e[1;5B": history-search-forward

# mappings for `Ctrl-left/right' for word moving
"\e[1;5C": forward-word
"\e[1;5D": backward-word

Meta-p: history-search-backward
Meta-n: history-search-forward

$endif

# ignore case while completing
set completion-ignore-case on

# # will display all alternatives for completion after one tab keypress
# set show-all-if-ambiguous on

# #* get Bash to display accented characters (Emacs *Meta Key* Problems in XTerm)

# # don't strip characters to 7 bits when reading
# set input-meta on
# # (synonym of 'meta-flag')

# # display characters with the eighth bit set directly rather than as
# # meta-prefixed characters
# set output-meta on

## .inputrc ends here
#+end_src

* Zsh specific
  :PROPERTIES:
  :tangle:   ./src/.zshrc
  :END:

** Examples

- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)
- [[http://grml.org/zsh/zsh-lovers.html][zsh-lovers]]

** Preamble

#+begin_src shell :noweb yes
## .zshrc --- Z Shell configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

#* Code:
#+end_src

** Variables

*** Search path

#+begin_src shell
# extend the PATH var
for MAYBE_PATH in "$HOME/bin" \
                  "$HOME/expect" \
                  "$HOME/winbin";
do
    # `-d' or `-x'?
    if [ -e $MAYBE_PATH ]; then
        PATH=$MAYBE_PATH:$PATH
    fi
done
#+end_src

*************** TODO Put the CWD (=.=) in PATH

If you add the CWD to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src shell
PATH=$PATH:.
#+end_src

*** Prompt

Zsh expects that every character in ~PS1~ will advance the cursor one space.
Wrap any non-printing escape sequences in ~%{...%}~, and it should work. So use
~%{\e[31m%}~, etc.

*************** TODO Define colors using ~terminfo~
See http://superuser.com/questions/239290/how-can-i-make-zsh-show-that-there-are-stashed-revisions-on-a-git-repo-whenever
*************** END

#+begin_src shell
#** 13 (info "(zsh)Prompt Expansion")

# some colors
local BLACK=$'%{\e[1;30m%}'
local RED=$'%{\e[1;31m%}'
local green=$'%{\e[0;32m%}'
local GREEN=$'%{\e[1;32m%}'
local yellow=$'%{\e[0;33m%}'
local reset=$'%{\e[0m%}'

# TODO Insert beep when last command has failed
# custom prompt settings
PROMPT="$green%n@%m$BLACK:$yellow%2. %(?.$GREEN.$RED)%?$reset%(!.#.$) "
    # ? - exit code of the previous command
    # n - user name
    # m - machine name
    # . - abbreviated pwd
    # ! - su?
#+end_src

The tricky part was getting the syntax for testing the exit code. The syntax
is ~%(x.true-string.false-string)~, where ~x~ is some arbitrary testing condition,
in this case, ~?~ for exit codes. After the first dot, if the test passes, show
true-string; if it fails, show false-string after the second dot.

https://github.com/olivierverdier/zsh-git-prompt

#+begin_src shell :tangle no
# Prompt on the right hand side of the screen (Git info).
. ~/Public/Repositories/git-prompt/zshrc.sh
RPROMPT='$(git_super_status)'
#+end_src

*************** TODO See predefined functions provided by =git-prompt.sh=
http://www.railstips.org/blog/archives/2009/02/02/bedazzle-your-bash-prompt-with-git-info/
*************** END

#+begin_src shell
. "/cygdrive/c/Program Files (x86)/Git/etc/git-prompt.sh"
setopt prompt_subst
export GIT_PS1_SHOWDIRTYSTATE=true
export GIT_PS1_SHOWSTASHSTATE=true
export GIT_PS1_SHOWUNTRACKEDFILES=true
export GIT_PS1_SHOWUPSTREAM=verbose
export GIT_PS1_DESCRIBE_STYLE=branch
export GIT_PS1_SHOWCOLORHINTS=true
export RPROMPT=$'$(__git_ps1 "%s")'
#+end_src

*** Customizing Zsh

Oh-my-Zsh...

I am fan of ~agnoster~.

Make sure to use a [[https://github.com/Lokaltog/powerline-fonts][patched up font]] though.

#+begin_note
If you right click them, there should be install option in the menu. Or you can
drag it straight to Windows Fonts folder
#+end_note

Good-looking fonts:
- UbuntuMono
- DejaVuSansMono
- DroidSansMono (bad?)

For Consolas, use: https://github.com/runsisi/consolas-font-for-powerline.

#+begin_src shell
ZSH=$HOME/.oh-my-zsh
ZSH_THEME="agnoster"
# ZSH_THEME="zsh2000"
DEFAULT_USER="Fabrice"
source ~/.oh-my-zsh/templates/zshrc.zsh-template
#+end_src

*** Command history

#+begin_src shell
# history
HISTFILE=$HOME/.histfile
HISTSIZE=1000
SAVEHIST=1000

# append new history lines instead of overwriting (important for multiple
# parallel Zsh sessions!)
setopt appendhistory

# don't save command more than once when occuring more often
setopt HIST_IGNORE_DUPS

# Use the same history file for all sessions
setopt SHARE_HISTORY
#+end_src

*** Term

Terminals:
- ~dumb~
- ~cygwin~
- ~emacs~
- ~screen~
- ~xterm~
- ~xterm-256color~ (choose this if Emacs looks ugly in a terminal)
- ~eterm-color~

Set the terminal type explicitly to get a nice 256 color palette (instead of the
default 8 colors):

#+begin_src shell
export TERM=xterm-256color
#+end_src

See what your color palet is for the terminal session:

#+begin_src shell :tangle no
tput colors
#+end_src

#+begin_seealso
Use the script ~colortest~ (on Linux distros) to output the default colors.
#+end_seealso

** Aliasing

Some global aliases (expand whatever their position).

#+begin_src shell
# Command line head / tail shortcuts
alias -g H='| head' ###
alias -g T='| tail' ###
alias -g G='| grep -E' ######
alias -g L="| less" #######
alias -g M="| less"
alias -g 21="2>&1"
alias -g DN1='1> /dev/null' #
alias -g DN2='2> /dev/null' #
#+end_src

#+begin_src shell
alias -g W='| wc -l' ####
alias -g S='| sort' ###
alias -g F=' | fmt -' ##
alias -g VM=/var/log/messages
alias -g A='| awk'
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g CA="| cat -A"
alias -g ND='$(ls -d *(/om[1]))'        # Newest directory.
alias -g NF='$(ls *(.om[1]))'           # Newest file.

alias -- cdwd='cd `pwd`'
alias -- cwd='echo $cwd'
alias h='history 1 | less +G'
alias -- l='ls -lg'
#+end_src

** Ledger

#+begin_src shell
export LEDGER=ledger
export LEDGER_FILE=/Users/fni/Personal/Business/Accounting/LEDGER.dat

# hledger print [REGEXP]... - show entries in Ledger format
    #! `hledger' is better than `ledger' in the sense that it does output
    #! 2 decimals whatever the figure, and that it does not output trailing
    #! spaces. There is no other difference (not even in indentation).

# other problem with ledger: reports onto 81 columns when using other DATEFMT...

alias -g LG="\$LEDGER -f \$LEDGER_FILE"
alias -g DATEFMT='-y %Y/%m/%d'  # for output
alias -g DAILY='--period "daily"'
alias -g DLM='--display "d>=[last month]"'  # display of last month
alias -g CLM='-p "last month"'  # computed total of last month
alias -g D1='--display "l<=1" --depth 1'
alias -g D2='--display "l<=2" --depth 2'
alias -g BALANCE_SHEET='^Assets ^Liabilities'
alias -g PROFIT_LOSS='^Expenses ^Income'

alias lastmonth='LG reg TLM'

# Ledger -f FILE [OPTIONS] [COMMAND [PATTERNS]]
# Ledger using `ledger', `hledger' or `beancount' (see `$LEDGER')
Ledger ()
{
    if [ $# -lt 1 ]; then
        cat << EOF 1>&2
Usage: $(basename $0) -f FILE [OPTIONS] [COMMAND [PATTERNS]]
    or $(basename $0) FILE   (if LEDGER=beancount)
EOF
    fi

    case ${LEDGER} in
        "beancount" )
            ;;

        * )   # default option
            shift;  # for the useless (but expected) `-f'
            ;;
    esac
    local LEDGER_M4_FILE=$1; shift;

    local LEDGER_FILE=sample-ledger.dat;
    case ${LEDGER} in
        "beancount" )
            m4 -D LEDGER=beancount ${LEDGER_M4_FILE} |\
            sed -e 's/\(.*\)(\(.*\)) \(.*\)/\1\3 | \2/g' > ${LEDGER_FILE}
            bean-web ${LEDGER_FILE} $@   # beancount Web interface
            ;;

        * )   # default option
            m4 ${LEDGER_M4_FILE} |\
            sed -e 's/^@/;@/' > ${LEDGER_FILE}
            ${LEDGER} -f ${LEDGER_FILE} $@
            ;;
    esac
    rm ${LEDGER_FILE}
}

# cat file.ledger | sed -e 's/@check/;@check/' | xargs bean-web

# Use wrapper scripts around gpg with armor on (The --armor option means ascii
# versus binary). You'll have to enter a password every time you want to run
# ledger.
#+end_src

** Functions

#+begin_src shell
#** 9 (info "(zsh)Functions")

# hgrep PATTERN - print the history lines matching PATTERN
hgrep ()
{
    history 0 | grep $1
}
#+end_src

** Source common files

#+begin_src shell
#** 17 (info "(zsh)Shell Builtin Commands")

# source common aliases
if [ -r $HOME/.commonshrc ]; then
    . $HOME/.commonshrc
fi
#+end_src

** Line Editor

Useful keybindings:

- ~M-q~ ::
     Type another command in the middle of a long command (look at man, etc.).

- ~M-.~ ::
     Recall the last argument of the previous command, and so on.

- ~C-r~ ::
     Do an interactive search across all of the history.

Useful commands:

- ~vared VAR~ ::
     Interactively edit variable VAR.

#+begin_src shell
#** 18 (info "(zsh)Zsh Line Editor")

# behave like Emacs when editing
bindkey -e

# mappings for `Ctrl-up/down' for matching commands from the history
bindkey ';5A' history-search-backward
bindkey ';5B' history-search-forward

# mappings for `Ctrl-left/right' for word moving
bindkey ';5C' forward-word
bindkey ';5D' backward-word

# beep on errors
setopt beep

# making Zsh beep like Bash when backspacing on an empty command line
backward-delete-char-beep ()
{
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep
#+end_src

** Completion Widgets

#+begin_src shell
#** 19 (info "(zsh)Completion Widgets")

# load general completion
autoload -Uz compinit && compinit

# display a list of completions when you give an ambiguous choice (like Bash)
setopt autolist

# Zsh will attempt to complete wildcards by expanding them in the command line
#+end_src

** Completion System

#+begin_src shell
#** 20 (info "(zsh)Completion System")

# case-insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'
#+end_src

** Zsh Modules

#+begin_src shell
## coloring stderr
STDERRRED=$'\e[1;31m'
zmodload zsh/system
color_err () {
    ## sysread & syswrite are part of `zsh/system'
    emulate -LR zsh
    while sysread
    do
        syswrite -o 2 "${STDERRRED}${REPLY}$terminfo[sgr0]"
    done
}

exec 2> >( color_err )
#+end_src

** Others

#+begin_src shell
# change directory given just path
setopt autocd

# use additional pattern matching features
setopt extendedglob

# unmatched patterns cause an error
setopt nomatch

# immediately report changes in background job status
setopt notify
#+end_src

#+begin_src shell
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: outline-minor
# End:

## .zshrc ends here
#+end_src

* Common
  :PROPERTIES:
  :tangle:   ./src/.commonshrc
  :END:

Everything in common between Bash and Z shell will come here.

** Preamble

#+begin_src shell :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .commonshrc --- Common features between (Linux and Cygwin) Bash and Z Shell

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

** Emacs (default editor)

Be sure one of these *editors* is *in your search path*!

#+begin_warning
Right now, I have instead hard-coded the path to Emacs in the
[[file:~/bin/emacsclient]] script.
#+end_warning

#+begin_src shell
# Find a suitable editor.
for editor in emacsclientw emacsclient emacs; do
    if $(which $editor >& /dev/null); then
        # Set EDITOR.
        case $editor in
            # emacsclient*)
            #     # # doesn't bother waiting for a response
            #     # export EDITOR="$editor --no-wait"
            #     export EDITOR="$editor -t"
            #     ;;
            ,*)
                export EDITOR="$editor"
                ;;
        esac

        alias e="$EDITOR"
        break
    fi
done
#+end_src

#+begin_src shell :tangle no
alias e="emacsclient -a emacs -n"       # -n is essential part
#+end_src

#+begin_note
Shouldn't we alias ~EDITOR~ to ~emacs -nw~?
#+end_note

#+begin_src shell
# Use `$EDITOR' for programs wanting an editor.
export VISUAL="$EDITOR"                 # For `crontab'.
export CVSEDITOR="$EDITOR"
export SVN_EDITOR="$EDITOR"
export EDIT="$EDITOR"
export ERROR_EDITOR="$EDITOR"
export FCEDIT="$EDITOR"                 # For the `fc' (fix command) builtin
                                        # command.
#+end_src

#+begin_src shell
alias em=emacs-minimal
#+end_src

#+begin_src shell
# ec FILE - open FILE in a running Emacs
ec ()
{
    emacsclient --no-wait "$1"
}
#+end_src

I connect to the server with either a terminal or a GUI client like this:

#+begin_example
alias et=emacsclient -t                 # New GUI frame.
alias ec=emacsclient -c                 # New terminal frame.
#+end_example

** Aliases

Aliases are abbreviations or alternative names (usually mnemonics) for
commands. They are commonly used to specify a few options to commands, and
then include the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like ~$1~.

#+begin_src shell
#* Aliasing
#+end_src

#+begin_src shell
LS_OPTIONS="$LS_OPTIONS --show-control-chars"
#+end_src

#+begin_src shell
# Grep through the aliases.
alias agrep='alias | grep -i'
#+end_src

*** Common aliases

#+begin_src shell
# enable color support of ls
if [ "$TERM" != "dumb" ]; then

    # # add my coloration scheme to directory listings
    # if [ -f $HOME/.dircolors ]; then
    #     eval "$(dircolors -b $HOME/.dircolors)"
    # else
    #     eval "$(dircolors -b)"
    # fi

    alias ls='ls --color=auto'
    alias ll="ls --color=auto --all --group-directories-first -l --human-readable --no-group"
                                        # Long listing and hidden files.
else
    alias ls='ls -CF'
fi
#+end_src

#+begin_src shell
alias df='df -kTh'
alias du='du -kh'
alias fd='find . -type d -name'
alias ff='find . -type f -name'
#+end_src

#+begin_src shell
# Play safe!
alias rm='rm -i'                        # Confirm removing file (prevent some
                                        # accidental mistakes).
alias cp='cp -i'                        # Confirm copy over an existing file.
alias mv='mv -i'                        # Confirm move over an existing file.
#+end_src

#+begin_note
This *alters* the *original* meaning of existing commands (that scripts don't expect
to see modified!).
#+end_note

#+begin_src shell
# Make an extract function!
alias tgz="tar -zxvf"
alias tbz2="tar -jxvf"
#+end_src

#+begin_src shell
alias -- ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
#+end_src

#+begin_src shell
# print PATH with each directory on a new line
alias path='echo $PATH | sed -e "s/:/\n/g"'

# path
alias where='type -all'
#+end_src

#+begin_src shell
alias mkall="./configure && make && sudo make install"

# sudo'ers
alias root="su - root"

# make executable
alias exe='chmod +x'

# chown current dir and subdirs
alias own='sudo chown -R $USER'
#+end_src

*** Single char shortcuts for some commands

#+begin_src shell
alias t='tail -f'
alias p="$PAGER"
alias m='man'
alias s='sudo'

alias j='jobs -l'
#+end_src

*** Git

#+begin_src shell
alias g='git'
#+end_src

*** SVN

#+begin_src shell
# search through files, ignoring .svn directories
alias svn_find="find . -not \( -name .svn -prune \)"

# function for grep'ing a string in every SVN revision of a file
# Usage: svn_grep_all_rev PATTERN FILE
svn_grep_all_rev() {
    svn log $2 | perl -n -e 'print "$1\n" if m/^r(\d*)\s+/' | (
        while read revision; do
            printf "\e[0;33m%s\e[0m\n" "Revision $revision:"
            svn cat -r $revision $2 | grep $1
            printf "\n"
        done
    )
}
#+end_src

*** History

#+begin_src shell
alias hgrep="history | grep -i"
#+end_src

*** SSH agent / GPG agent

#+begin_src shell
alias keyon="ssh-add -t 10800"  # add identity
alias keyoff="ssh-add -D"       # remove all identities
alias keylist="ssh-add -l"      # list all identities
#+end_src

*** Debian

#+begin_src shell
alias aps='aptitude search'
#+end_src

*** System admin (NMAP, etc.)

#+begin_src shell
alias ports="netstat -alpe --ip"
#+end_src

#+begin_src shell
# alias scan="nmap -sS -O"
alias nm="nmap -sS -O -PI -PT"
alias portscan="nmap -sT -PT -R "
alias nmap_fast="nmap -F -T5 --top-ports 300"
#+end_src

#+begin_src shell
# nmap ()
# {
#     echo "Enter port #"
#     read port
#     echo "Enter IP range"
#     read range
#     sudo nmap -sT -p $port -P0 -v -T 4 -oG dump-$port-${range////_}.txt $range
#     grep -i open dump-$port-${range////_}.txt
# }
#+end_src

#+begin_src shell
# localnet - find the local network in CIDR notation
localnet ()
{
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}

# whoisonline [TARGET] - list hosts that are online
whoisonline ()
{
    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Discovering online hosts in $net..."
    sudo nmap -sP $net | awk '/Host / && / up/ { print $0; }'
}

# localps [TARGET] - list open ports on hosts that are online
localps ()
{
    local hostip
    local t1
    local t2
    local t3

    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi

    for hostip in $(nmap -sP $net | grep -E 'Host .* up' | cut -d " " -f2-2);
    do
        t1=$(ping -c 4 $hostip | grep -e PING | cut -d " " -f1-2 | cut -d " " -f2-4) ;
        t2=$(ping -c 4 $hostip | grep -e rtt | cut -d "/" -f5-5) ;
        t3=$(sudo nmap -sS $hostip | grep " open ") ;
        echo -e $t1 " " $t2 "ms\n" $t3 "\n";
    done
}

# watchport HOST PORT - watch TCP port PORT on machine HOST
watchport ()
{
    while true; do clear; nmap $1 -PN -p $2; sleep 5; done
}

# rdns [TARGET] - perform reverse DNS lookups
rdns ()
{
    local net
    if [ -n "$1" ]; then
      net="$1"
    else
      net=$(localnet)
    fi
    echo "Performing reverse DNS lookups in $net..."
    nmap -R -sL $net |\
    awk '{if ($3 != "not") print "Host " $3 " is " $2}' | grep '('
    # You could add "--dns-servers x.x.x.x" after the "-sL" if you need the
    # lookups to be performed on a specific DNS server.
}
#+end_src

#+begin_src shell
# anonymous wget (using Privoxy and Tor)
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror="wget -v --tries=0 --continue --force-directories --mirror --no-parent"

alias off='sudo shutdown -h now'
#+end_src

*** Org

For branches for which we want to make some development, and keep in track with
~master~:

#+begin_src shell
update_org () {
    (   # Directory changes made in a subshell do not carry over to the parent shell.
        cd $HOME/Public/Repositories/org-mode;
        git fetch --all --verbose \
            && git rebase origin \
            && make autoloads \
            && echo DON\'T make clean \
            && echo DON\'T make \
            && echo DON\'T sudo make install \
            && echo DON\'T make doc \
            && make info \
            && sudo make install-info \
            && printf "Running org_test, please wait (this can take a while)...\n" \
            && org_test 2>&1 >/dev/null | tail -n 3
    )
}
#+end_src

*************** TODO Don't regenerate autoloads, doc, etc. if nothing new was pulled

#+begin_src shell
org_test () {
    (
        cd $HOME/Public/Repositories/org-mode;
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

#+begin_src shell
if [ -d "$HOME/Public/Repositories/org-bash-utils" ]
then
    PATH="$HOME/Public/Repositories/org-bash-utils:$PATH"
    source $HOME/Public/Repositories/org-bash-utils/org-alias
    source $HOME/Public/Repositories/org-bash-utils/awk-alias
fi
#+end_src

*** MCit tools

#+begin_src shell
alias sp=sendpatch
#+end_src

** Grep

#+begin_src shell
# display the matched pattern in color
alias grep='grep --color=auto'
#+end_src

Change the color of ~grep~:

#+begin_src shell
export GREP_COLOR="0;30;43"
#+end_src

#+begin_note
The colors are defined by the environment variable ~GREP_COLORS~. The deprecated
environment variable ~GREP_COLOR~ is still supported, but its setting does not
have priority.

But apparently, this is not the case on my system. ~GREP_COLOR~ is the one that
worked...
#+end_note

#+begin_src shell
# grep through the running processes
alias pgrep='pgrep -fl'
#+end_src

** Pager

Set the user's preferred text pager (~cat~, ~more~ or ~less~) that will be used by
programs such as ~man~ or ~git diff~ to display pages.

~less~ is faster than anything else around (with exception of possibly ~more~, but
this one feels really archaic).

#+begin_src shell
PAGER="less"
#+end_src

With the ~less~ command, you can *scroll up* in the file as well as down; with the
~more~ command, you can only *scroll down* the file.

#+begin_src shell
alias more="less"
#+end_src

*** Less

Man pages colors:

#+begin_src shell
# Colored man pages: http://linuxtidbits.wordpress.com/2009/03/23/less-colors-for-man-pages/
# Less Colors for Man Pages
export LESS_TERMCAP_mb=$'\E[01;31m'     # enter_blink_mode.
export LESS_TERMCAP_md=$'\E[01;38;5;74m' # enter_bold_mode.
export LESS_TERMCAP_so=$'\E[38;5;016m\E[48;5;220m' # enter_standout_mode (mode
                                                   # line at the bottom).
export LESS_TERMCAP_us=$'\E[04;38;5;146m' # enter_underline_mode.
export LESS_TERMCAP_me=$'\E[0m'         # exit_attribute_mode (end modes like
                                        # `mb' and `md').
export LESS_TERMCAP_se=$'\E[0m'         # exit_standout_mode.
export LESS_TERMCAP_ue=$'\E[0m'         # exit_underline_mode.
# See `terminfo'.
#+end_src

#+begin_seealso
[[file:~/.minttyrc][.minttyrc]] to *fix colors* and fonts.
#+end_seealso

See also
http://stackoverflow.com/questions/10535432/tmux-man-page-search-highlighting to
highlight man pages.

#+begin_src shell
# tailoring `less'
LESS="--quit-at-eof --ignore-case --long-prompt --raw-control-chars"
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
#+end_src

#+begin_note
If you want that ~less~ does not clear the terminal when quitting, use the ~-X~
option.
#+end_note

#+begin_note
Without ~--raw-control-chars~, ~less~ outputs the colors as raw escape codes, that
is it does not *interpret colors*. With it, ~git diff~ finally shows colors...
#+end_note

*** Most

To add a bit of color to your man pages, you can install ~most~.

#+begin_note
But it does not *highlight search results*: when searching using ~/~, it only
scrolls to the location...
#+end_note

See http://www.cyberciti.biz/faq/unix-linux-color-man-pages-configuration/.

** GraphicsMagick

#+begin_src shell
# GraphicsMagick
alias GIF="gm convert -verbose -interlace LINE"
alias thumb="gm convert -geometry 100x100 -interlace LINE -verbose"
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize ()
{
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES
    do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # obscure but useful string operations
        # (see http://www.arachnoid.com/linux/shell_programming.html)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

** Next

#+begin_src shell
# use `pkill' (which is pgrep + kill in a single command)

# show only my processes
alias mytop='top -u $USERNAME'

# directory history
alias dh='dirs -v'

# list all files modified in the last 24 hours (last full day)
alias oneday='find . -mtime -1 -print'

# XXX my traceroute
if $(which mtr >& /dev/null); then
    alias ping=mtr
fi

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 compare /proc with ps (against rootkits)
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# get gpg-key from keyserver
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'

# # 040210 grep
# alias g='find . -type f -print0 | xargs -0 grep'
#+end_src

#+begin_src shell
# 040319 send files via netcat
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/}|nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'


# If I want to find out which lines in a file are duplicated and want to print
# them, the following awk script helps:
# awk 'seen[$0]++ == 1' <filename>


# honor embedded linefeeds when displaying packets
alias ngrep='ngrep -W byline'

# echo my current external IP address
alias whatismyip='curl -s http://whatismyip.org'

# Web radio stations
alias europe1='mplayer http://vipicecast.yacast.net/europe1'
alias europe2='mplayer mms://vipmms9.yacast.fr/encodereurope2'
alias nrj='mplayer mms://vipnrj.yacast.fr/encodernrj'
alias rtl='mplayer http://streaming.radio.rtl.fr/rtl-1-44-96'
alias rtl2='mplayer http://streaming.radio.rtl.fr/rtl2-1-44-96'


case $(uname -s) in
    Linux*)
        alias vpnup='sudo test; exec sudo openvpn --config $HOME/.hide/OpenVPN-config/mcbe.ovpn --writepid /tmp/openvpn.pid &'  # --daemon'
        alias vpndown='sudo kill -INT `cat /tmp/openvpn.pid`'
        ;;

    CYGWIN*)
        alias vpnup='cd $HOME/.hide/OpenVPN-config; openvpn --config mcbe.ovpn --writepid c:/cygwin/tmp/openvpn.pid &'  # --daemon'
        alias vpndown='killall openvpn'
        ;;
esac

# make `du' human readable
alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'  # ordered by size

# make `df' human readable
alias df='df -h'


# `unp' is for archive extract

# dir
alias back="cd -"
alias home="cd $HOME"


export GS_OPTIONS="-sPAPERSIZE=a4"
alias pdfmerge="gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./finished.pdf" # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

** Functions

#+begin_src shell
# list all files modified today only (since start of day only, i.e. 00:00)
today ()
{
    touch -t `date +%m%d0000` /tmp/$$
    find . -type f -newer /tmp/$$
    rm -f /tmp/$$
}
#+end_src

** Other

#+begin_src shell
# clean [-r] - remove useless files (recursively)
clean ()
{
    if [ "$1" = "-r" ]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" -o \
            -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" -o \
            -name "*.~BASE~" -o -name ".*.~BASE~" \) -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}

# swap FILE1 FILE2 - swap FILE1 and FILE2
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap ()
{
    if [ $# != 2 ]; then
        return 1
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f $1 $tmpfile
    mv -f $2 $1
    mv -f $tmpfile $2
    return 0
}
#+end_src

** Postamble

#+begin_src shell
# This is for the sake of Emacs.
# Local Variables:
# ispell-local-dictionary: "en_US"
# End:

# .commonshrc ends here
#+end_src

* Install environment
  :PROPERTIES:
  :tangle:   ./bin/install-sh-files
  :END:

Symlink the files.

#+begin_src shell :results silent :shebang #!/bin/bash
ln -f -s $(pwd)/../src/.bashrc        ~/.bashrc
ln -f -s $(pwd)/../src/.bash_profile  ~/.bash_profile
ln -f -s $(pwd)/../src/.commonshrc    ~/.commonshrc
ln -f -s $(pwd)/../src/.inputrc       ~/.inputrc
ln -f -s $(pwd)/../src/.zshrc         ~/.zshrc
#+end_src

Or something like...

#+begin_src shell :results silent :shebang #!/bin/bash :tangle no
if [ -d "$HOME/src/shellrc/src" ]
then
    PATH="$HOME/src/shellrc/src:$PATH"
fi
#+end_src
