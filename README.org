#+TITLE:     Shell configuration files
#+AUTHOR:    Fabrice Niessen
#+EMAIL:     (concat "fniessen" at-sign "pirilampo.org")
#+Time-stamp: <2014-10-21 Tue 10:44>
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   ^:{}

#+PROPERTY:  eval no
#+SETUPFILE: bigblow-pirilampo.setup

* Documentation

[[http://www.bash2zsh.com/zsh_refcard/refcard.pdf][Zsh Reference Card]]

* Startup files

There are three *sorts of shells*:

- (interactive) *login* (for which =c:/cygwin/etc/profile= and =.profile= are read,
  which sources =.bashrc= as well)

  *Note --* Launching Cygwin Terminal (login shell) does not load ~.bashrc~ on its
  own, it only loads ~.bash_profile~. Hence, the need to have a ~.bash_profile~
  sourcing ~.bashrc~...

- *interactive* (non-login) (for which =.bashrc= is read)

- normal shell, i.e. one that's running a *script* (bash does not execute any
  initialization file in this case!)

  =$tty= is empty.

We just let =.profile= also read =.bashrc= and put everything in =.bashrc=.

*Read* [[http://shreevatsa.wordpress.com/2008/03/30/zshbash-startup-files-loading-order-bashrc-zshrc-etc/][Zsh/Bash startup files loading order]]:

- For bash, put stuff in =~/.bashrc=, and make =~/.bash_profile= source it.
- For zsh, put stuff in =~/.zshrc=, which is always executed.

To recover the default bash configuration files, get their copy from
=/etc/skel=.

If you get a couple of "command not found" errors and a corrupt prompt at
startup, then your =.bashrc= is probably in Windows text format (~\r\n~ line
endings).  Make sure your editor is in Unix format when creating text files.

** What to put where?

Login shell runs .profile (or .bash_profile or .bash_login) on startup. Set
your env variables in there, cuz sub-shells will inherit the env vars. Then
make .profile run your .bashrc:

#+begin_src sh
. .bashrc
#+end_src

Interactive runs .bashrc. Since it inherits envs, but not aliases, put your
aliases in this file.

Shell scripts, cron jobs, and the like, run with a bare shell: no bashrc or
profiles are run. No kidding you get 4 env vars set, the bare
minimum. Therefore your PATH won't work very well so you often have to give an
abs pathname like in crontab:

#+begin_src sh
right: 0 0 * * 2 /usr/sbin/apachectl restart
wrong: 0 0 * * 2 apachectl restart
#+end_src

From https://www.linuxquestions.org/questions/linux-general-1/difference-between-normal-shell-and-login-shell-14983/#post4828786

** Note

In ~c:/cygwin/etc/profile~,

- ~/usr/local/bin~ is appended to the =PATH=!!

  And, except when root, it is almost always wrong to have ~/usr/local/bin~ after
  any system path.

- =TZ= (time zone) is set... which gives wrong times (1 hour difference) in Emacs
  when called from ~c:/cygwin/Cygwin.bat~!!

* Terminals

- =dumb=
- =cygwin=
- =emacs=
- =screen=
- =xterm=
- =xterm-256color= (choose this if Emacs looks ugly in a terminal)
- =eterm-color=

* Bash specific
  :PROPERTIES:
  :tangle:   ./src/.bashrc
  :END:

Le =!= en shell permet plein de trucs sympa.

- =!!= refait la dernière commande
- =!cmd= refait la dernière commande commençant par =cmd=
- =!cmd:p= permet de visualiser sans éxecuter la dernière commande commençant
  par =cmd=
- =!$= est le dernier mot du ligne de commande précédent
- =!cmd:$= est le dernier mot du dernier ligne de commande commençant par =cmd=
- =!*= est l'ensemble de la dernière ligne de commande à part le premier mot

Pourquoi ce dernier est-il utile ?  Pense à ceci :

#+begin_src sh :tangle no
$ gm convret -size 120x120 input.png -resize 120x120 -draw "gravity southeast text 0,0 'Dave Neary'" output.jpg
bash: convret: command not found
$ gm convert !*
#+end_src

** Profile

#+begin_src sh :tangle ./src/.bash_profile
# User dependent .bash_profile file

# source the user's .bashrc if it exists
if [ -f "${HOME}/.bashrc" ] ; then
  source "${HOME}/.bashrc"
fi
#+end_src

** Preamble

#+name: current-year
#+begin_src emacs-lisp :eval yes :results silent :tangle no
(format-time-string "%Y")
#+end_src

#+begin_src sh :noweb yes
## .bashrc --- Bourne Again Shell configuration file (for interactive shells)

# Copyright (C) 2003-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, dotfile, config

#    _               _
#   | |__   __ _ ___| |__  _ __ ___
#   | '_ \ / _` / __| '_ \| '__/ __|
#  _| |_) | (_| \__ \ | | | | | (__
# (_)_.__/ \__,_|___/_| |_|_|  \___|
#

# This file is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.

# This file is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public
# License along with this file; if not, write to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.

#* Code:

# modify to taste
#+end_src

I think the following is important for tools such as =rsync= (and Emacs
Tramp?)...

#+begin_src sh
# if not running interactively, don't do anything
[[ "$-" != *i* ]] && return
#+end_src

** Variables

*** Search path

Where to look for executable files.

The global search PATH is defined in the file `/etc/environment'

Note that PATH should already be marked as exported, so reexporting is not
needed.

#+begin_src sh
# specify the directories that the shell is to look through to find a
# command. These directories are searched in the order in which they appear.
for MAYBE_PATH in "$HOME/bin" \
                  "$HOME/expect" \
                  "$HOME/winbin"
do
    if [ -d "$MAYBE_PATH" ]; then
        PATH="$MAYBE_PATH:$PATH"
    fi
done

# add the current directory as last component in the search path
# (not to include for root, for security reasons)
if [ ! "$(id -u)" = "0" ]; then
    PATH="$PATH:."
fi
#+end_src

*** Prompt

Appearance of the prompt.

Note =\[...\]= used by the shell to count proper length.

#+begin_src sh
#*** Controlling the Prompt

# regular colors
green="\[\e[0;32m\]"
yellow="\[\e[0;33m\]"

# bold colors
BLACK="\[\e[1;30m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"

reset="\[\e[0m\]"

#**** PS1 --- Default interaction prompt

#**** PS2 --- Continuation interactive prompt

#**** PS3 --- Prompt used by "select" inside shell script

#**** PS4 --- Used by "set -x" to prefix tracing output

# get line numbers when you run with `-x'
PS4='+'${green}'[$0:${LINENO}]+ '${reset}
# single quotes (otherwise, this line number is taken)

# If you are looking at performance issues, put `$SECONDS' in the PS4 prompt
# as well
#+end_src

#+begin_src sh
#**** PROMPT_COMMAND

# to be called just before the prompt is printed
precmd ()
{
    RET=$?

    # set a color prompt (unless in Emacs)
    case $TERM in
        cygwin|xterm*|rxvt-unicode)
            local color_prompt=yes
            ;;
        dumb)
            # `M-x shell' under Cygwin Emacs
            # `M-x eshell' under EmacsW32
            # Tramp
            local color_prompt=no
            ;;
        emacs)
            # `M-x shell' under EmacsW32
            local color_prompt=no
            ;;
        eterm-color)
            # `M-x term' under Cygwin Emacs
            local color_prompt=no
            ;;
    esac

    # colorful prompt, based on whether the previous command succeeded or not
    if [ $RET -eq 0 ]; then
        HILIT_RET=${GREEN}
    else
        HILIT_RET=${RED}
    fi

    # replace the `$HOME' prefix by `~' in the current directory
    if [ "$HOME" = "${PWD:0:${#HOME}}" ]; then
        myPWD="~${PWD:${#HOME}}"
    else
        myPWD=$PWD
    fi

    # how many characters of the path should be kept
    local pwd_max_length=15

    if [ ${#myPWD} -gt $pwd_max_length ]; then
        local pwd_offset=$(( ${#myPWD} - $pwd_max_length ))
        myPWD="...${myPWD:$pwd_offset:$pwd_max_length}"
    fi

    # prompt character
    if [ "$USERNAME" = "root" ]; then
        local PROMPTCHAR="#"
    else
        local PROMPTCHAR="$"
    fi

    if [ "$color_prompt" = "yes" ]; then
        PS1="${green}\u@\h${BLACK}:${yellow}${myPWD}${HILIT_RET} ${RET}${reset}${PROMPTCHAR} "
    else
        PS1="\u@\h:${myPWD} ${RET}${PROMPTCHAR} "
    fi
}

# execute the content of the `PROMPT_COMMAND' just before displaying the `PS1'
# variable (but don't confuse Tramp)
[ $TERM = "dumb" ] || PROMPT_COMMAND=precmd
#+end_src

*** Command history

Access and modify commands that you had previously typed at the command line.

#+begin_src sh
# history
HISTFILE=$HOME/.bash_history # if paranoiac, `/dev/null'
HISTSIZE=1000
HISTFILESIZE=1000
HISTIGNORE="&:[bf]g:exit"
HISTCONTROL=ignoredups
#+end_src

*** Term

*** Display

** Code

#+begin_src sh
#** Source global rc file (if any)

# source global definitions if the session is interactive (to avoid problems
# like "stdin: is not a tty" when ssh'ing to a remote machine)
if ([ $(expr index "$-" i) -ne 0 ] && [ -f /etc/bashrc ]); then
    . /etc/bashrc
fi
#+end_src

A common cause is =mesg y= in =/etc/bashrc= on the remote machine, hence the user
has to try avoiding sourcing it (on the *remote* machine) in non-interactive
sessions.

#+begin_src sh
#** Default permissions

# permissions on newly created files
umask 022 # prevent new dirs and files from being group and world writable

if [ "$USERNAME" = "root" ]; then
    umask 077  # stricter
fi
#+end_src

#+begin_src sh
#** Shell options

# correct minor misspellings of cd pathnames
shopt -s cdspell
#+end_src

** Next

#+begin_src sh
#** 5 (info "(bashref)Shell Variables")

# set MANPATH so it includes user's private man if it exists
# do the same with MANPATH
#if [ -d $HOME/man ]; then
#    MANPATH=$HOME/man:"${MANPATH}"
#    export MANPATH
#fi

# LANG="en_US.utf8"
# LC_CTYPE="en_US.utf8"
# LC_ALL="C"   # fixes the problem of strange characters in the man page
# XXX These should be set in `/etc/default/locale', via `sudo update-locale'

# XXX Set DISPLAY?

# colon separated list of directories to search for manual pages
#ifnset MANPATH "/usr/man"
    # TODO don't define it like that: does not work under Ubuntu!
    # See `/etc/manpath.config'

# Info readers (standalone + Emacs Info mode)
INFOPATH="/usr/share/info:$INFOPATH"
# include a trailing colon on `INFOPATH' to concatenate the Emacs
# `Info-default-directory-list' when searching for info files
INFOPATH="$HOME/src/emacs-w3m/doc:$INFOPATH"
INFOPATH="$HOME/src/gnus/texi:$INFOPATH"
INFOPATH="$HOME/Downloads/emacs/site-lisp/auctex-11.86/doc:$INFOPATH"
# INFOPATH="$HOME/texlive/2010/texmf/doc/info:$INFOPATH"
INFOPATH="$HOME/Public/Repositories/org-mode/doc:$INFOPATH"
#+end_src

#+begin_src sh :tangle no
# Functions to help us manage environment variables

# setenv [VAR] [value] - set environment variable
setenv () { eval $1="\$2" export $1; }

# unsetenv [VAR] - unset environment variable
unsetenv () { unset "$@"; }

# ifnset [VAR] [value] - set environment variable only if not set yet
ifnset () { eval $1=\${$1-"\$2"} export $1; }

# ifnull [VAR] [value] - set environment variable if not set yet or if NULL
ifnull () { eval $1=\${$1:-"\$2"} export $1; }

# append [VAR] [path] - append path separated by `:'
append () { eval $1=\${$1:+\$$1${2:+:}}\$2 export $1; }

# prepend [VAR] [path] - prepend path separated by `:'
prepend () { eval $1=\$2\${$1:+${2:+:}\$$1} export $1; }

# showvalue [VAR]... - print out the value of variables given their name
showvalue () { for i in $*; do eval echo "$i = \\\`\$$i\'"; done; }
#+end_src

** Source common files

~.commonshrc~ contains miscellaneous definitions common to Bash and Zsh.

An *alias* is a simple string substitution.

By default, it is *not expanded in non-interactive shells* (scripts, and even
functions called in an interactive shell!).

In general, it should not do more than *change the default options of a command*.

#+begin_src sh
#** 4.2 or 6.6 Aliases

# source common definitions
if [ -r "$HOME/.commonshrc" ]; then
    . $HOME/.commonshrc
fi
#+end_src

** Next

#+begin_src sh
# ALTER the ORIGINAL meaning of existing commands (that scripts don't
# expect to see modified!)
alias df='df -kTh'
alias du='du -kh'
alias cp='cp -i'   # confirm copy over an existing file
alias mv='mv -i'   # confirm move over an existing file
alias rm='rm -i'   # confirm removing file (prevent some accidental mistakes)
alias ssh="ssh -C"
alias more="less"

alias rmdir="rm -fr"

# path
alias where='type -all'

# start up Windows applications associated with a particular file extension
# directly from the Bash prompt
alias start="cmd /c start"
alias start="cygstart" # under Cygwin

alias lo="locate -i" # case insensitive search
alias lg="locate -r '.*' | grep -i"

alias mkall="./configure && make && sudo make install"

alias tvm="tail -f /var/log/messages"

# sudo'ers
alias root="su - root"

# force the radio to always sync at 2 Mbps, even if other speeds are available
alias iwconfigslow="sudo iwconfig eth1 rate 2M"

# shortcuts
alias c="clear"
alias E="env | sort"
alias h="history 25"
alias j="jobs -l"
alias m=$PAGER
alias p=$PAGER
alias se="sudoedit"
alias X="ssh-agent startx &"
alias z="suspend"

# misc commands
alias dos2unix="sed s/
//g"
alias unix2dos="sed s/\$/
/"

alias hgrep="history | grep"

alias keyon="ssh-add -t 10800"  # add identity
alias keyoff="ssh-add -D"       # remove all identities
alias keylist="ssh-add -l"      # list all identities

alias kill9="kill -9"

# make an extract function!
alias tgz="tar -zxvf"
alias tbz2="tar -jxvf"

alias nfiles="find . -type f | wc -l"

alias ports="netstat -alpe --ip"

# most used programs
alias web="firefox &"
# alias scan="nmap -sS -O"
alias nm="nmap -sS -O -PI -PT"
alias portscan="nmap -sT -PT -R "

# anonymous wget (using Privoxy and Tor)
alias aget='wget --execute "http_proxy = http://127.0.0.1:8118" --proxy'
alias mirror="wget -v --tries=0 --continue --force-directories --mirror --no-parent"

# ngrep -i -w 'user|pass' port 110
# ngrep -d eth0 -i 'USER|PASS' tcp port 80
# ngrep google port 80
# ngrep -i 'rcpt to|mail from' tcp port smtp
# ngrep -q -t -wi "login" port 23


#** 8.6 Programmable Completion

complete -A helptopic help
complete -A hostname ssh telnet nmap rlogin ftp ping host traceroute nslookup rexec


#** Misc functions

saneperms ()
{
    find . -type d -print0 | xargs -0 chmod 755
    find . -type f -print0 | xargs -0 chmod ${1:=644}
}


# # search for various types or README file in dir and display them in $PAGER
# readme ()
# {
#     local files
#     files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
#     if (($#files)); then
#         $PAGER $files
#     else
#         print 'No README files.'
#     fi
# }

# # Get a file's basename, dirname, extension, etc
#
# # get extension; everything after last '.'
# ext=${file##*.}
#
# # basename
# basename=`basename "$file"`
# # everything after last '/'
# basename=${file##*/}
#
# # dirname
# dirname=`dirname "$file"`
# # everything before last '/'
# basename=${file%/*}

# TODO If possible, get the lines colored (exe in green) or suffixed (`*' for
# exe, `/' for dir, etc.)
ff ()
{
    find . -name $@ -print 2>&1 | grep -v "find:"
}

safetmp ()
{
    test -d $HOME || exit 1
    test -d $HOME/tmp || mkdir $HOME/tmp
    echo $HOME/tmp/safetmp.$(hostname).$(date +%s).$$
}

# Copies my public key to the given server
sendkey ()
{
    local HOSTNAME="$*"
    scp $HOME/.ssh/id_rsa.pub $USER@$HOSTNAME:/home/$DOMAIN/$USER/.ssh/authorized_keys
    # The PuTTY developers strongly recommend you use RSA
}

# Copies my `.bashrc' to the given server
sendbash ()
{
    local HOSTNAME="$*"
    scp $HOME/.bashrc $USER@$HOSTNAME:/home/$DOMAIN/$USER/.bashrc
}

# Copies my public key and bashrc to the given server
rsetup ()
{
    local HOSTNAME="$*"
    sendkey $HOSTNAME
    sendbash $HOSTNAME
}

# gpg
searchkey ()
{
    gpg --keyserver pgp.mit.edu --fingerprint --search-key "$@";
}

#*** GPG functions

encrypt ()
{
    # Use ascii armor
    gpg -ac --no-options "$1"
}

bencrypt ()
{
    # No ascii armor
    # Encrypt binary data. jpegs/gifs/vobs/etc.
    gpg -c --no-options "$1"
}

decrypt ()
{
    gpg --no-options "$1"
}

pe ()
{
# Passphrase encryption program
# Created by Dave Crouse 01-13-2006
# Reads input from text editor and encrypts to screen.
    clear
    echo "         Passphrase Encryption Program";
    echo "--------------------------------------------------"; echo "";
    which $EDITOR &>/dev/null
    if [ $? != "0" ]; then
        echo "It appears that you do not have a text editor set in your .bashrc file.";
        echo "What editor would you like to use ? " ;
        read EDITOR ; echo "";
    fi
    echo "Enter the name/comment for this message :"
    read comment
    $EDITOR passphraseencryption
    gpg --armor --comment "$comment" --no-options --output
    passphraseencryption.gpg --symmetric passphraseencryption
    shred -u passphraseencryption ; clear
    echo "Outputting passphrase encrypted message"; echo "" ; echo "" ;
    cat passphraseencryption.gpg ; echo "" ; echo "" ;
    shred -u passphraseencryption.gpg ;
    read -p "Hit enter to exit" temp; clear
}

keys ()
{
    # Opens up kgpg keymanager
    kgpg -k
}

encryptfile ()
{
    zenity --title="zcrypt: Select a file to encrypt" --file-selection > zcrypt
    encryptthisfile=`cat zcrypt`;rm zcrypt
    # Use ascii armor
    #  --no-options (for NO gui usage)
    gpg -acq --yes ${encryptthisfile}
    zenity --info --title "File Encrypted" --text "$encryptthisfile has been encrypted"
}

decryptfile ()
{
    zenity --title="zcrypt: Select a file to decrypt" --file-selection > zcrypt
    decryptthisfile=`cat zcrypt`;rm zcrypt
    # NOTE: This will OVERWRITE existing files with the same name !!!
    gpg --yes -q ${decryptthisfile}
    zenity --info --title "File Decrypted" --text "$encryptthisfile has been decrypted"
}


# # have one SSH agent ready at all times
# if [ "$SSH_AUTH_SOCK" = "" ]; then
#     # check to see if there's an ssh-agent running
#     eval $(ssh-agent)
#     ssh-add
# fi

#*** Unison

# unison the current working directory only
uwd ()
{
    p=$(pwd -P)
    p=${p#*$HOME/my-unison-root/}
    p=${p#*$HOME/my-unison-root}

    if [ -d "$HOME/my-unison-root/$p" ]; then
        unison profile-name-for-uwd -path "$p"
    else
        echo "$p is not a directory in a Unison hierarchy on this machine"
    fi
}


# look for definitions
jargon ()
{
    BROWSER="links"
    JARGON_URL="http://info.astrian.net/jargon/terms"
    for i in ${*}; do
        ${BROWSER} ${JARGON_URL}/${i}.html
    done
}

# acronym finder
acro ()
{
    if [ $# = 0 ]; then
        echo "Usage: $0 acronym"
        echo "Purpose: expand an acronym"
    else
       #links "http://www.ucc.ie/cgi-bin/acronym?$1"
        links "http://www.acronymfinder.com/af-query.asp?String=exact&Acronym=$1"
    fi
}

# current weather forecasts
alias weather="lynx term=vt100 http://weather.ec.gc.ca/forecast/city_e.html?yyz"

# nmap ()
# {
#     echo "Enter port #"
#     read port
#     echo "Enter IP range"
#     read range
#     sudo nmap -sT -p $port -P0 -v -T 4 -oG dump-$port-${range////_}.txt $range
#     grep -i open dump-$port-${range////_}.txt
# }

timesync ()
{
    if [ $(id -u) = 0 ]; then
        ntpdate -u swisstime.ethz.ch
    else
        echo "Must be root"
    fi
}

# Searching for keyword(s) with Google
google ()
{
    w3m "http://www.google.com/search?q="$1"";
}


# immediately opens the first match
texman ()
{
    locate $* | grep pdf | grep texlive | head -1 | xargs open;
}

texlist ()
{
    locate $* | grep "\(pdf\|dvi\)" | grep "\ (texlive\|gwTeX\)";
}

# http_proxy="http://hellman:8080"
#+end_src

** Postamble

#+begin_src sh
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: shell-script
# mode: outline-minor
# sh-shell: bash
# End:

## .bashrc ends here
#+end_src

* Zsh specific
  :PROPERTIES:
  :tangle:   ./src/.zshrc
  :END:

** Examples

- [[http://aperiodic.net/phil/prompt/][Phil!'s ZSH Prompt]]
- [[http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/][My Extravagant Zsh Prompt]] (with Git Repository Information)

** Preamble

#+begin_src sh :noweb yes
## .zshrc --- Z Shell configuration file (for interactive shells)

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: zsh, dotfile, config

#* Install:

# For Cygwin users: Create a shortcut for zsh by using the `mkzsh' command.

#* Code:
#+end_src

** Variables

*** Search path

#+begin_src sh
# extend the PATH var
for MAYBE_PATH in "$HOME/bin" \
                  "$HOME/expect" \
                  "$HOME/winbin";
do
    # `-d' or `-x'?
    if [ -e $MAYBE_PATH ]; then
        PATH=$MAYBE_PATH:$PATH
    fi
done
#+end_src

*************** TODO Put the CWD (=.=) in PATH

If you add the CWD to your PATH, just do it:

- for *non-root users*,
- as the *last entry* (so, the current directory is only checked as a last
  resort).

#+begin_src sh
PATH=$PATH:.
#+end_src

*** Prompt

Zsh expects that every character in =PS1= will advance the cursor one space.
Wrap any non-printing escape sequences in =%{...%}=, and it should work. So use
=%{\e[31m%}=, etc.

#+begin_src sh
#** 13 (info "(zsh)Prompt Expansion")

# some colors
local BLACK=$'%{\e[1;30m%}'
local RED=$'%{\e[1;31m%}'
local green=$'%{\e[0;32m%}'
local GREEN=$'%{\e[1;32m%}'
local yellow=$'%{\e[0;33m%}'
local reset=$'%{\e[0m%}'

# TODO Insert beep when last command has failed
# custom prompt settings
PROMPT="$green%n@%m$BLACK:$yellow%2. %(?.$GREEN.$RED)%?$reset%(!.#.$) "
    # ? - exit code of the previous command
    # n - user name
    # m - machine name
    # . - abbreviated pwd
    # ! - su?
#+end_src

The tricky part was getting the syntax for testing the exit code. The syntax
is =%(x.true-string.false-string)=, where =x= is some arbitrary testing condition,
in this case, =?= for exit codes. After the first dot, if the test passes, show
true-string; if it fails, show false-string after the second dot.

https://github.com/olivierverdier/zsh-git-prompt

#+begin_src sh
# # prompt on the right hand side of the screen
# RPROMPT="[%t]"

# git info
. ~/Public/Repositories/git-prompt/zshrc.sh
RPROMPT='$(git_super_status)'
#+end_src

*** Command history

#+begin_src sh
# history
HISTFILE=$HOME/.histfile
HISTSIZE=1000
SAVEHIST=1000

# append new history lines instead of overwriting (important for multiple
# parallel Zsh sessions!)
setopt appendhistory

# don't save command more than once when occuring more often
setopt HIST_IGNORE_DUPS

# Use the same history file for all sessions
setopt SHARE_HISTORY
#+end_src

*** Term

Sett the terminal type explicitly:

#+begin_src sh
export TERM=xterm-256color
#+end_src

*** Display

** Aliasing

#+begin_src sh
# some global aliases (expand whatever their position)
alias -g L="| less" #######
alias -g M="| most"
alias -g G='| grep -E' ######
alias -g W='| wc -l' ####
alias -g H='| head' ###
alias -g S='| sort' ###
alias -g T='| tail' ###
alias -g F=' | fmt -' ##
alias -g 21="2>&1"
alias -g DN1='1> /dev/null' #
alias -g DN2='2> /dev/null' #
alias -g VM=/var/log/messages
alias -g A='| awk'
alias -g A1="| awk '{print \$1}'"
alias -g A2="| awk '{print \$2}'"
alias -g A3="| awk '{print \$3}'"
alias -g A4="| awk '{print \$4}'"
alias -g A5="| awk '{print \$5}'"
alias -g A6="| awk '{print \$6}'"
alias -g A7="| awk '{print \$7}'"
alias -g A8="| awk '{print \$8}'"
alias -g A9="| awk '{print \$9}'"
alias -g CA="| cat -A"
alias -g ND='$(ls -d *(/om[1]))' # newest directory
alias -g NF='$(ls *(.om[1]))'    # newest file

alias -g EG='|& egrep'
alias -g EH='|& head'
alias -g EL='|& less'
alias -g ET='|& tail'
alias -g X='| xargs'

alias -- cdwd='cd `pwd`'
alias -- cwd='echo $cwd'
alias h='history 1 | less +G'
alias -- l='ls -lg'
alias find='noglob find'
#+end_src

** Ledger

#+begin_src sh
export LEDGER=ledger
export LEDGER_FILE=/home/sva/Personal/Business/Accounting/LEDGER.dat

# hledger print [REGEXP]... - show entries in Ledger format
    #! `hledger' is better than `ledger' in the sense that it does output
    #! 2 decimals whatever the figure, and that it does not output trailing
    #! spaces. There is no other difference (not even in indentation).

# other problem with ledger: reports onto 81 columns when using other DATEFMT...

alias -g LG="\$LEDGER -f \$LEDGER_FILE"
alias -g DATEFMT='-y %Y/%m/%d'  # for output
alias -g DAILY='--period "daily"'
alias -g DLM='--display "d>=[last month]"'  # display of last month
alias -g CLM='-p "last month"'  # computed total of last month
alias -g D1='--display "l<=1" --depth 1'
alias -g D2='--display "l<=2" --depth 2'
alias -g BALANCE_SHEET='^Assets ^Liabilities'
alias -g PROFIT_LOSS='^Expenses ^Income'

alias lastmonth='LG reg TLM'

# Ledger -f FILE [OPTIONS] [COMMAND [PATTERNS]]
# Ledger using `ledger', `hledger' or `beancount' (see `$LEDGER')
Ledger ()
{
    if [ $# -lt 1 ]; then
        cat << EOF 1>&2
Usage: $(basename $0) -f FILE [OPTIONS] [COMMAND [PATTERNS]]
    or $(basename $0) FILE   (if LEDGER=beancount)
EOF
    fi

    case ${LEDGER} in
        "beancount" )
            ;;

        * )   # default option
            shift;  # for the useless (but expected) `-f'
            ;;
    esac
    local LEDGER_M4_FILE=$1; shift;

    local LEDGER_FILE=sample-ledger.dat;
    case ${LEDGER} in
        "beancount" )
            m4 -D LEDGER=beancount ${LEDGER_M4_FILE} |\
            sed -e 's/\(.*\)(\(.*\)) \(.*\)/\1\3 | \2/g' > ${LEDGER_FILE}
            bean-web ${LEDGER_FILE} $@   # beancount Web interface
            ;;

        * )   # default option
            m4 ${LEDGER_M4_FILE} |\
            sed -e 's/^@/;@/' > ${LEDGER_FILE}
            ${LEDGER} -f ${LEDGER_FILE} $@
            ;;
    esac
    rm ${LEDGER_FILE}
}

# cat file.ledger | sed -e 's/@check/;@check/' | xargs bean-web

# Use wrapper scripts around gpg with armor on (The --armor option means ascii
# versus binary). You'll have to enter a password every time you want to run
# ledger.
#+end_src

** Functions

#+begin_src sh
#** 9 (info "(zsh)Functions")

# ll ()
# {
#     ls -lag $* | more
# }

term ()
{
    setopt noglob;
    unset TERMCAP;
    eval `tset -s -I -Q - $*`
}

# hgrep PATTERN - print the history lines matching PATTERN
hgrep ()
{
    history 0 | grep $1
}
#+end_src

** Source common files

#+begin_src sh
#** 17 (info "(zsh)Shell Builtin Commands")

# source common aliases
if [ -r $HOME/.commonshrc ]; then
    . $HOME/.commonshrc
fi
#+end_src

** Line Editor

Useful keybindings:

- =M-q= ::
     Type another command in the middle of a long command (look at man, etc.).

- =M-.= ::
     Recall the last argument of the previous command, and so on.

- =C-r= ::
     Do an interactive search across all of the history.

Useful commands:

- =vared VAR= ::
     Interactively edit variable VAR.

#+begin_src sh
#** 18 (info "(zsh)Zsh Line Editor")

# behave like Emacs when editing
bindkey -e

# mappings for `Ctrl-up/down' for matching commands from the history
bindkey ';5A' history-search-backward
bindkey ';5B' history-search-forward

# mappings for `Ctrl-left/right' for word moving
bindkey ';5C' forward-word
bindkey ';5D' backward-word

# beep on errors
setopt beep

# making zsh beep like Bash when backspacing on an empty command line
backward-delete-char-beep ()
{
    if (( CURSOR == 0 )); then
        zle beep
    fi
    zle backward-delete-char
}
zle -N backward-delete-char-beep
bindkey "^?" backward-delete-char-beep
#+end_src

** Completion Widgets

#+begin_src sh
#** 19 (info "(zsh)Completion Widgets")

# load general completion
autoload -Uz compinit && compinit

# display a list of completions when you give an ambiguous choice (like Bash)
setopt autolist

# zsh will attempt to complete wildcards by expanding them in the command line
#+end_src

** Completion System

#+begin_src sh
#** 20 (info "(zsh)Completion System")

# case-insensitive completion
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

if [ "$TERM" != "dumb" ]; then
    # eval "$(dircolors -b)"
    alias ls='ls --color=always'
else
    alias ls='ls -CF'
fi
#+end_src

** Zsh Modules

#+begin_src sh
## coloring stderr
STDERRRED=$'\e[031m'
zmodload zsh/system
color_err () {
    ## sysread & syswrite are part of `zsh/system'
    emulate -LR zsh
    while sysread
    do
        syswrite -o 2 "${STDERRRED}${REPLY}$terminfo[sgr0]"
    done
}

exec 2> >( color_err )
#+end_src

** Others

#+begin_src sh
# change directory given just path
setopt autocd

# use additional pattern matching features
setopt extendedglob

# unmatched patterns cause an error
setopt nomatch

# immediately report changes in background job status
setopt notify
#+end_src

#+begin_src sh
#* Local Variables

# This is for the sake of Emacs.
# Local Variables:
# mode: outline-minor
# End:

## .zshrc ends here
#+end_src

* Common
  :PROPERTIES:
  :tangle:   ./src/.commonshrc
  :END:

Everything in common between Bash and Z shell will come here.

** Preamble

#+begin_src sh :noweb yes
# Hey Emacs, this is a -*- sh -*- file
## .commonshrc --- Common features between (Linux and Cygwin) Bash and Z Shell

# Copyright (C) 2009-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: bash, zsh, dotfile, config
#+end_src

** Default editor

Be sure one of these *editors* is *in your search path*!

Note -- Right now, I have instead hard-coded the path to Emacs in the
[[file:~/bin/emacsclient]] script.

#+begin_src sh
# set the user's preferred text editor
for editor in emacsclientw emacsclient emacs vi; do
    # find a suitable editor
    if $(which $editor >& /dev/null); then
        case $editor in
            # emacsclient*)
            #     # # doesn't bother waiting for a response
            #     # export EDITOR="$editor --no-wait"
            #     export EDITOR="$editor -t"
            #     ;;
            ,*)
                export EDITOR="$editor"
                ;;
        esac
        alias e="$EDITOR"
        alias edit="$EDITOR"
        break
    fi
done

# FIXME 2010-11-04 This causes problems when scp'ing .bash_profile (for
# example) when this .bashrc is deployed onto the remote SSH server.
# [ -z "$EDITOR" ] && echo "No suitable editor found."
# [ -z "$EDITOR" ] || showvalue EDITOR

# use `$EDITOR' for programs wanting an editor
export VISUAL="$EDITOR" # for crontab
export CVSEDITOR="$EDITOR"
export SVN_EDITOR="$EDITOR"
export EDIT="$EDITOR"
export ERROR_EDITOR="$EDITOR"
export FCEDIT="$EDITOR" # for the fc (fix command) builtin command
#+end_src

#+begin_src sh :tangle no
alias e="emacsclient -a emacs -n"       # -n is essential part
#+end_src

** Aliases

Aliases are abbreviations or alternative names (usually mnemonics) for
commands. They are commonly used to specify a few options to commands, and
then include the rest of the command line.

Aliases should usually be kept simple. If not, they should be converted to:
- shell functions, or
- shell scripts.

An alias cannot have an argument like =$1=.

#+begin_src sh
#* Aliasing

LS_OPTIONS="$LS_OPTIONS --show-control-chars"

# enable color support of ls
if [ "$TERM" != "dumb" ]; then

    # # add my coloration scheme to directory listings
    # if [ -f $HOME/.dircolors ]; then
    #     eval "$(dircolors -b $HOME/.dircolors)"
    # else
    #     eval "$(dircolors -b)"
    # fi

    alias ls='ls --color=auto'
    alias ll="ls --color=yes --all --group-directories-first -l --human-readable --no-group"
            # long listing and hidden files
fi

alias -- ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

alias s=sudo
alias w=which
alias q='clear && exit' # `x' is left for X Server...

# print PATH with each directory on a new line
alias path='echo $PATH | sed -e "s/:/\n/g"'

alias apts='aptitude search'
alias apti='sudo aptitude install --with-recommends'
alias aptrm='sudo aptitude remove'
#+end_src

** Emacs / Org

#+begin_src sh
alias em=emacs-minimal
#+end_src

For branches for which we want to make some development, and keep in track with
=master=:

#+begin_src sh
update_org () {
    (   # Directory changes made in a subshell do not carry over to the parent shell.
        cd $HOME/Public/Repositories/org-mode;
        git fetch --all --verbose \
            && git rebase origin \
            && make autoloads \
            && echo DON\'T make clean \
            && echo DON\'T make \
            && echo DON\'T sudo make install \
            && echo DON\'T make doc \
            && make info \
            && sudo make install-info \
            && printf "Running org_test, please wait (this can take a while)...\n" \
            && org_test 2>&1 >/dev/null | tail -n 3
    )
}
#+end_src

#+begin_src sh
org_test () {
    (
        cd $HOME/Public/Repositories/org-mode;
        mkdir /tmp/tmp-orgtest 2> /dev/null # TMPDIR must exist!
        TMPDIR=/tmp/tmp-orgtest emacs -Q --batch -L lisp/ -L testing/ -l org-test.el --eval '(setq org-confirm-babel-evaluate nil)' -f org-test-run-batch-tests
    )
}
#+end_src

#+begin_src sh
if [ -d "$HOME/Public/Repositories/org-bash-utils" ]
then
    PATH="$HOME/Public/Repositories/org-bash-utils:$PATH"
    source $HOME/Public/Repositories/org-bash-utils/org-alias
    source $HOME/Public/Repositories/org-bash-utils/awk-alias
fi
#+end_src

** Grep

#+begin_src sh
export GREP_COLORS="mt=01;33"

# grep through the running processes
alias pgrep='pgrep -fl'
#+end_src

** Pager

Set the user's preferred text pager (=cat=, =more= or =less=) that will be used by
programs such as =man= or =git diff= to display pages.

=less= is faster than anything else around (with exception of possibly =more=, but
this one feels really archaic).

#+begin_src sh
PAGER="less"
#+end_src

Without =--raw-control-chars=, =less= outputs the colors as raw escape codes, that
is it does not *interpret colors*. With it, =git diff= finally shows colors...

#+begin_src sh
# tailoring `less'
LESS="--quit-at-eof --ignore-case --long-prompt --raw-control-chars"
# export LESS="-P ?c<- .?f%f:Standard input.  ?n:?eEND:?p%pj\%.. .?c%ccol . ?mFile %i of %m  .?xNext\ %x.%t   Press h for help"
#+end_src

** GraphicsMagick

#+begin_src sh
# GraphicsMagick
alias GIF="gm convert -verbose -interlace LINE"
alias thumb="gm convert -geometry 100x100 -interlace LINE -verbose"
alias region='sleep 3; gm import selection$(date "+%Y%m%d%H%M%S").jpg'
alias screenshot='sleep 5; gm import -window root screen$(date "+%Y%m%d%H%M%S").jpg'
alias window='sleep 3; gm import -frame window$(date "+%Y%m%d%H%M%S").jpg'

gmresize ()
{
    FILES="$@"
    SCALE="1024x768"
  # for i in *.(gif|jpeg|jpg|png);
    for i in $FILES
    do
        echo "Processing image $i ..."
        gm convert -scale $SCALE "$i" $(basename "$i" .${i##*.})-$SCALE.${i##*.}
        # obscure but useful string operations
        # (see http://www.arachnoid.com/linux/shell_programming.html)
    done
}

# find . -name "*png" | xargs -l -i basename -s ".png" "{}" | xargs -l -i  gm convert -quality 85% "{}.png" "{}.jpg"
#+end_src

** MCit tools

#+begin_src sh
alias sp=sendpatch
#+end_src

** Next

#+begin_src sh
# # dirty (?) hack
# alias killspell='kill `pidof hunspell`'
# # use `pkill' (which is pgrep + kill in a single command)

# use `htop' instead of `top'
# XXX sudo aptitude install htop
if $(which htop >& /dev/null); then
    alias top=htop
fi

# show only my processes
alias mytop='top -u $USERNAME'
alias mytop='htop -u $USERNAME'

# grep through the aliases
alias agrep='alias | grep -i'

# directory history
alias dh='dirs -v'

# play safe!
alias rm='rm -i'
alias mv='mv -i'
alias cp='cp -i'

# display the matched pattern in color
alias grep='grep --color'

# list all files modified in the last 24 hours (last full day)
alias oneday='find . -mtime -1 -print'

# XXX my traceroute
if $(which mtr >& /dev/null); then
    alias ping=mtr
fi

# hping[2] (run as root!)
alias myping="hping2 -c 100 -2 -p 7 $1"
alias myping2="hping2 -d 500 -c 100 -2 -p 7 $1"

# 030925 compare /proc with ps (against rootkits)
alias myps="sudo ls -d /proc/* | grep '[0-9]' | wc -l ; sudo ps ax | wc -l"

# get gpg-key from keyserver
alias getkey='gpg --keyserver keys.gnupg.net --recv-keys'

# 040210 grep
alias g='find . -type f -print0 | xargs -0 grep'

# search through files, ignoring .svn directories
alias svn_find="find . -not \( -name .svn -prune \)"

# function for grep'ing a string in every SVN revision of a file
# Usage: svn_grep_all_rev PATTERN FILE
svn_grep_all_rev() {
    svn log $2 | perl -n -e 'print "$1\n" if m/^r(\d*)\s+/' | (
        while read revision; do
            printf "\e[0;33m%s\e[0m\n" "Revision $revision:"
            svn cat -r $revision $2 | grep $1
            printf "\n"
        done
    )
}

# 040319 send files via netcat
# on sending side:
#  send() {j=$*; tar cpz ${j/%${!#}/}|nc -w 1 ${!#} 51330;}
#  send dir* $HOST
# Info:
#  ${!#} gibt den letzten Parameter (den Hostnamen) zurück,
#  ${j/%${!#}/} die übrigen (Liste der Dateien oder Verzeichnisse).
alias receive='nc -vlp 51330 | tar xzvp'


# If I want to find out which lines in a file are duplicated and want to print
# them, the following awk script helps:
# awk 'seen[$0]++ == 1' <filename>


# honor embedded linefeeds when displaying packets
alias ngrep='ngrep -W byline'

# echo my current external IP address
alias whatismyip='curl -s http://whatismyip.org'

# shortcut to making executable
alias exe='chmod +x'

# chown current dir and subdirs
alias own='sudo chown -R $USER'


# Web radio stations
alias europe1='mplayer http://vipicecast.yacast.net/europe1'
alias europe2='mplayer mms://vipmms9.yacast.fr/encodereurope2'
alias nrj='mplayer mms://vipnrj.yacast.fr/encodernrj'
alias rtl='mplayer http://streaming.radio.rtl.fr/rtl-1-44-96'
alias rtl2='mplayer http://streaming.radio.rtl.fr/rtl2-1-44-96'


alias off='sudo shutdown -h now'


case $(uname -s) in
    Linux*)
        alias vpnup='sudo test; exec sudo openvpn --config $HOME/.hide/OpenVPN-config/mcbe.ovpn --writepid /tmp/openvpn.pid &'  # --daemon'
        alias vpndown='sudo kill -INT `cat /tmp/openvpn.pid`'
        ;;

    CYGWIN*)
        alias vpnup='cd $HOME/.hide/OpenVPN-config; openvpn --config mcbe.ovpn --writepid c:/cygwin/tmp/openvpn.pid &'  # --daemon'
        alias vpndown='killall openvpn'
        ;;
esac

# make `du' human readable
alias du='du -h'
alias du1='du -h --max-depth=1'
alias dus='du -ms * | sort -rn'  # ordered by size

# make `df' human readable
alias df='df -h'


# `unp' is for archive extract

# dir
alias back="cd -"
alias home="cd $HOME"


export GS_OPTIONS="-sPAPERSIZE=a4"
alias pdfmerge="gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=./finished.pdf" # pdfjoin
alias booklet="psbook | psnup -2 | pstops '2:0,1U(21cm,29.7cm)'"
# for Win32, choose gswin32c
#+end_src

** Functions

#+begin_src sh
#* Functions

# list all files modified today only (since start of day only, i.e. 00:00)
today ()
{
    touch -t `date +%m%d0000` /tmp/$$
    find . -type f -newer /tmp/$$
    rm -f /tmp/$$
}

# ff PATTERN - find file named PATTERN
ff ()
{
    find . -name $1 -print
}

# files PATH - list files in PATH
files ()
{
    find $1 -type f -print
}

# line N FILE - show line N of FILE
line ()
{
    sed -n "$1 p" $2
}
#+end_src

** Emacsclient

#+begin_src sh
# ec FILE - open FILE in a running Emacs
ec ()
{
    emacsclient --no-wait "$1"
}
#+end_src

I connect to the server with either a terminal or a GUI client like this:

alias et=emacsclient -t # new GUI frame
alias ec=emacsclient -c # new terminal frame

** Other

#+begin_src sh
# clean [-r] - remove useless files (recursively)
clean ()
{
    if [ "$1" = "-r" ]; then
        find . \( -name "#*" -o -name "*~" -o -name ".*~" -o \
            -name "*.~[0-9]*~"\ -o -name ".*.~[0-9]*~" -o \
            -name "*.~BASE~" -o -name ".*.~BASE~" \) -ok rm "{}" ";"
    else
        rm -i \#* *~ .*~ *.~[0-9]*~ .*.~[0-9]*~ *.~BASE~ .*.~BASE~
    fi
}

# swap FILE1 FILE2 - swap FILE1 and FILE2
# Useful when you want to try a config file obtained from elsewhere, and also
# keep the old version.
swap ()
{
    if [ $# != 2 ]; then
        return 1
    fi
    tmpfile=/tmp/.swapper.$$.$RANDOM
    mv -f $1 $tmpfile
    mv -f $2 $1
    mv -f $tmpfile $2
    return 0
}


#** Networking toolbox

# localnet - find the local network in CIDR notation
localnet ()
{
    IP_ADDRESS=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*addr:\([0-9.]*\).*/\1/")
    # we could use `nm-tool' from `network-manager'

    NETMASK=$(ifconfig | grep "inet addr:" | head -n 1 | sed "s/.*Mask:\([0-9.]*\).*/\1/")

    # calculate network value
    echo $(ipcalc -n -b $IP_ADDRESS $NETMASK | grep Network | awk '{print $2}')
}


# whoisonline [TARGET] - list hosts that are online
whoisonline ()
{
    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi
    echo "Discovering online hosts in $net..."
    sudo nmap -sP $net | awk '/Host / && / up/ { print $0; }'
}


# localps [TARGET] - list open ports on hosts that are online
localps ()
{
    local hostip
    local t1
    local t2
    local t3

    local net
    if [ -n "$1" ]; then
        net="$1"
    else
        net=$(localnet)
    fi

    for hostip in $(nmap -sP $net | grep -E 'Host .* up' | cut -d " " -f2-2);
    do
        t1=$(ping -c 4 $hostip | grep -e PING | cut -d " " -f1-2 | cut -d " " -f2-4) ;
        t2=$(ping -c 4 $hostip | grep -e rtt | cut -d "/" -f5-5) ;
        t3=$(sudo nmap -sS $hostip | grep " open ") ;
        echo -e $t1 " " $t2 "ms\n" $t3 "\n";
    done
}


# watchport HOST PORT - watch TCP port PORT on machine HOST
watchport ()
{
    while true; do clear; nmap $1 -PN -p $2; sleep 5; done
}


# rdns [TARGET] - perform reverse DNS lookups
rdns ()
{
    local net
    if [ -n "$1" ]; then
      net="$1"
    else
      net=$(localnet)
    fi
    echo "Performing reverse DNS lookups in $net..."
    nmap -R -sL $net |\
    awk '{if ($3 != "not") print "Host " $3 " is " $2}' | grep '('
    # You could add "--dns-servers x.x.x.x" after the "-sL" if you need the
    # lookups to be performed on a specific DNS server.
}
#+end_src

** Postamble

#+begin_src sh
# This is for the sake of Emacs.
# Local Variables:
# ispell-local-dictionary: "en_US"
# End:

# .commonshrc ends here
#+end_src

* InputRC
  :PROPERTIES:
  :tangle:   ./src/.inputrc
  :END:

This file controls the behavior of line input editing for programs that use
the Gnu *Readline* library. Existing programs include FTP, Bash, and Gdb.

#+begin_note
Zsh doesn't use the =inputrc= file.
#+end_note

#+begin_src sh :noweb yes
## .inputrc --- my Readline Init File

# Copyright (C) 2005-<<current-year()>> Fabrice Niessen

# Author: Fabrice Niessen <(concat "fniessen" at-sign "pirilampo.org")>
# Keywords: readline, dotfile, config

#    _                   _
#   (_)_ __  _ __  _   _| |_ _ __ ___
#   | | '_ \| '_ \| | | | __| '__/ __|
#  _| | | | | |_) | |_| | |_| | | (__
# (_)_|_| |_| .__/ \__,_|\__|_|  \___|
#           |_|

# This file is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of
# the License, or (at your option) any later version.

# This file is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public
# License along with this file; if not, write to the Free
# Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
# MA 02111-1307, USA.

#* Code:

# modify to taste

# first, include any system-wide settings (ignored if one has his own
# `.inputrc')
$include /etc/skel/.inputrc
$include /etc/inputrc

# allow Meta (Alt) key bindings [line added to the top of my `.inputrc']
set convert-meta on

# behave like Emacs when editing
set editing-mode emacs
    # Ctrl-a/e      Start/End of line
    # Ctrl-f/b      Forward/Backward one character
    # Ctrl-d        Delete one character
    # Ctrl-k        Kill line
    # Ctrl-p/n      Previous/Next command in history
    # Ctrl-r        Search for command in history
    # Ctrl-i/TAB    File name completion

# some defaults / modifications for the Emacs mode
$if mode=emacs

# mappings for `Ctrl-up/down' for matching commands from the history
"\e[1;5A": history-search-backward
"\e[1;5B": history-search-forward

# mappings for `Ctrl-left/right' for word moving
"\e[1;5C": forward-word
"\e[1;5D": backward-word

Meta-p: history-search-backward
Meta-n: history-search-forward

$endif

# ignore case while completing
set completion-ignore-case on

# # will display all alternatives for completion after one tab keypress
# set show-all-if-ambiguous on

# #* get Bash to display accented characters (Emacs *Meta Key* Problems in XTerm)

# # don't strip characters to 7 bits when reading
# set input-meta on
# # (synonym of 'meta-flag')

# # display characters with the eighth bit set directly rather than as
# # meta-prefixed characters
# set output-meta on

## .inputrc ends here
#+end_src

* Install environment
  :PROPERTIES:
  :tangle:   ./bin/install-sh-files
  :END:

Symlink the files.

#+begin_src sh :results silent :shebang #!/bin/bash
ln -f -s $(pwd)/../src/.bashrc        ~/.bashrc
ln -f -s $(pwd)/../src/.bash_profile  ~/.bash_profile
ln -f -s $(pwd)/../src/.commonshrc    ~/.commonshrc
ln -f -s $(pwd)/../src/.inputrc       ~/.inputrc
ln -f -s $(pwd)/../src/.zshrc         ~/.zshrc
#+end_src

Or something like...

#+begin_src sh :results silent :shebang #!/bin/bash :tangle no
if [ -d "$HOME/src/shellrc/src" ]
then
    PATH="$HOME/src/shellrc/src:$PATH"
fi
#+end_src
